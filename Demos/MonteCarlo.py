#!/usr/bin/env python
"""

    !!! Not certified fit for any purpose, use at your own risk !!!

    Copyright (c) Rex Sutton 2004-2017.

   Either with Heston model,
        compare plain vanilla option prices obtained via FFT and Monte Carlo,
        compare plain vanilla option prices obtained via FFT with particle Monte Carlo,

    or for any model (with characteristic function),
        compare plain vanilla option prices obtained via FFT with local volatility Monte Carlo.
"""
import argparse
import functools
import json

import matplotlib.pyplot as plt
import numpy as np

from mpl_toolkits.mplot3d import Axes3D

import env
import vollab as vl


def plot_paths(paths):
    """
    Plot paths matrix generated by Monte Carlo.
    Args:
        paths: The paths matrix.
    """
    fig = plt.figure()
    sub = fig.add_subplot(111)
    sub.plot(paths)
    sub.title.set_text("Sample paths.")
    sub.set_ylabel("Values")
    sub.set_xlabel("Time Step")


def plot_surface(x_axis, y_axis, z_values, tol=1e-8):
    """
        Plot a surface using MatPlotLib.
        The tolerance controls what appears to be a bug when plotting flat surfaces.
    Args:
        x_axis: The x axis.
        y_axis: The y axis.
        z_values: The matrix of surface values.
        tol: Tolerance for rounding numbers to precision.
    """
    x_mesh, y_mesh = np.meshgrid(x_axis, y_axis, indexing='ij')
    z_matrix = np.zeros([len(x_axis), len(y_axis)], dtype=np.float64)

    for i in range(0, len(x_axis)):
        for j in range(0, len(y_axis)):
            z_matrix[i, j] = np.floor(z_values[i][j] / tol)*tol

    fig = plt.figure()
    sub = fig.add_subplot(111, projection='3d')
    sub.plot_surface(x_mesh, y_mesh, z_matrix)
    sub.title.set_text("Call prices as a function of strike and maturity.")
    sub.set_xlabel("Strike")
    sub.set_ylabel("Maturity")
    sub.set_zlabel("Price")


def compute_sim_call_prices(strikes, simulated_process):
    """
    Compute call prices from simulated values.
    Args:
        strikes: The strikes.
        simulated_process: Matrix of simulated values by time.

    Returns: A matrix of call prices.

    """
    sim_call_prices = []
    for simulations in simulated_process:
        sim_call_prices_at_tenor = []
        for strike in strikes:
            temp = 0.0
            for process_value in simulations:
                intrinsic = process_value - strike
                temp += intrinsic if intrinsic > 0.0 else 0.0
            sim_call_prices_at_tenor.append(temp / len(simulations))
        sim_call_prices.append(sim_call_prices_at_tenor)
    return sim_call_prices


def test_heston(params):
    """
    For the Heston model compare plain vanilla option prices obtained via FFT and Monte Carlo.
    Args:
        params: A dictionary of parameter values used to override defaults.
    """
    # create the Monte Carlo
    monte_carlo = vl.HestonMonteCarlo()
    monte_carlo.__dict__.update(params)
    # create market parameters
    market_params = vl.MarketParams()
    market_params.__dict__.update(params)
    # create the characteristic function
    characteristic_function = vl.create_characteristic_function('Heston')
    characteristic_function.__dict__.update(params)
    # select the range of strikes to plot
    strike_selector = functools.partial(vl.select_strike,
                                        0.7 * market_params.spot,
                                        1.3 * market_params.spot)
    # generate a surface of call prices using FFT
    tenors = monte_carlo.time_axis
    selected_strikes, tenors, call_prices_by_tenor_by_strike \
        = vl.compute_call_prices_matrix(characteristic_function,
                                        market_params,
                                        strike_selector,
                                        tenors)
    # run simulation
    simulated_stock = monte_carlo.sample()[0]
    # plot simulation
    plot_paths(simulated_stock)
    sim_call_prices = compute_sim_call_prices(selected_strikes, simulated_stock)
    # plot surfaces
    plot_surface(selected_strikes, tenors, np.transpose(sim_call_prices))
    # plot_surface(selected_strikes, tenors, np.transpose(call_prices_by_tenor_by_strike))
    # abs_errors = np.array(sim_call_prices) - np.array(call_prices_by_tenor_by_strike)
    # plot_surface(selected_strikes, tenors, np.transpose(abs_errors), tol=1e-8)
    print "Close the plot window to continue..."
    plt.show()


def setup_local_vol(model, params):
    """
    For the specified model compute plain vanilla option prices obtained via FFT,
     and the local volatility surface.

    Args:
        model: A string identifying the model's characteristic function.
        params: A dictionary of parameter values used to override defaults.
    """
    # create market parameters
    market_params = vl.MarketParams()
    market_params.__dict__.update(params)
    # create the characteristic function
    characteristic_function = vl.create_characteristic_function(model)
    characteristic_function.__dict__.update(params)
    # select the range of strikes to work with
    strike_selector = functools.partial(vl.select_strike,
                                        0.7 * market_params.spot,
                                        1.3 * market_params.spot)
    # generate a surface out to five years
    tenors = np.linspace(0.0, 50 * 0.1, 1 + 50)
    # calculate call prices
    selected_strikes, tenors, call_prices_by_fft = \
        vl.compute_call_prices_matrix(characteristic_function,
                                      market_params,
                                      strike_selector,
                                      tenors)
    # calculate the local vol surface
    floored_tenors = np.array([tenor for tenor in tenors if tenor > 0.25])
    local_vol_matrix_results \
        = vl.compute_local_vol_matrix(characteristic_function,
                                      market_params,
                                      strike_selector,
                                      floored_tenors)
    # make the spline surface
    local_vol_spline_surface = vl.SplineSurface(selected_strikes,
                                                floored_tenors,
                                                local_vol_matrix_results[2],
                                                tenors)

    # print local_vol_spline_surface(market_params.spot, 0.0)
    return selected_strikes, tenors, call_prices_by_fft, local_vol_spline_surface


def test_hpmc(params):
    """
    For the specified model compare plain vanilla option prices obtained via FFT,
     with local volatility Monte Carlo.

    Args:
        model: A string identifying the model's characteristic function.
        params: A dictionary of parameter values used to override defaults.
    """
    selected_strikes, tenors, call_prices_by_fft, local_vol_spline_surface \
        = setup_local_vol('Heston', params)
    # create the variance Monte Carlo
    variance_monte_carlo = vl.HestonMonteCarlo()
    variance_monte_carlo.__dict__.update(params)
    # create the particle Monte Carlo
    particle_monte_carlo = vl.ParticleMonteCarlo(local_vol_spline_surface,
                                                 selected_strikes,
                                                 variance_monte_carlo)

    simulated_stock = particle_monte_carlo.sample()[0]
    plot_paths(simulated_stock)
    # call prices
    sim_call_prices = compute_sim_call_prices(selected_strikes, simulated_stock)
    plot_surface(selected_strikes, tenors, np.transpose(sim_call_prices))
    # plot_surface(selected_strikes, tenors, np.transpose(call_prices_by_fft))
    # plot_surface(selected_strikes,
    #              tenors,
    #              np.transpose(np.array(sim_call_prices) - np.array(call_prices_by_fft)))
    print "Close the plot window to continue..."
    plt.show()


def test_local_vol(model, params):
    """
    For the specified model compare plain vanilla option prices obtained via FFT,
     with local volatility Monte Carlo.

    Args:
        model: A string identifying the model's characteristic function.
        params: A dictionary of parameter values used to override defaults.
    """
    selected_strikes, tenors, call_prices_by_fft, local_vol_spline_surface \
        = setup_local_vol(model, params)
    # create the Monte Carlo
    monte_carlo = vl.LocalVolMonteCarlo(local_vol_spline_surface)
    monte_carlo.__dict__.update(params)
    simulated_stock = monte_carlo.sample()[0]
    plot_paths(simulated_stock)
    # call prices
    sim_call_prices = compute_sim_call_prices(selected_strikes, simulated_stock)
    plot_surface(selected_strikes, tenors, np.transpose(sim_call_prices))
    # plot_surface(selected_strikes, tenors, np.transpose(call_prices_by_fft))
    # plot_surface(selected_strikes,
    #              tenors,
    #              np.transpose(np.array(sim_call_prices) - np.array(call_prices_by_fft)))
    print "Close the plot window to continue..."
    plt.show()


def main():
    """ The main entry point function.
    """
    parser = argparse.ArgumentParser()
    # parameters are a dictionary.
    parser.add_argument("-m", "--model",
                        help="The stochastic model.",
                        choices=["BlackScholes",
                                 "Heston",
                                 "HestonMC",
                                 "HestonPMC",
                                 "VarianceGamma"],
                        default="HestonMC")
    parser.add_argument("-p", "--params",
                        help="The parameter dictionary.",
                        default="{}",
                        type=json.loads)
    # parse args
    args = parser.parse_args()
    # Heston has specialized implementation for comparison.
    if args.model == "HestonMC":
        test_heston(args.params)
    elif args.model == "HestonPMC":
        test_hpmc(args.params)
    else:
        test_local_vol(args.model, args.params)


if __name__ == "__main__":
    main()
